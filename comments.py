def gcd(p,q):
	#Вычисление НОД(наибольший общий делитель) числа по алгоритму Евклида
	#Основан на том, что НОД(a,b)=a, если b=0 и НОД(a,b)=НОД(b, a mod b), если b!=1.
	#Первое очевидно, т.к. 0 делится на любое число, а второе нетрудно доказать.
	if q==0:
		return p
	return gcd(q,p%q)

def lcm(p,q):
	#Вычисление НОК(наименьшее общее кратное) двух чисел
	#Основано на формуле НОК(a,b) = (a*b)/НОД(a,b)
	return p*q/gcd(p,q)

def CC(p,k,m):
	m=str(m)
	#перевод числа m из сс с основанием p в сс с основанием k
	a=['A','B','C','D','E','F']
	c=[] #это для цифр, в том числе для букв А,В,С,.. в десятичном представлении
	ten=0 #здесь будет храниться 10-ичная запись числа
	power=len(m) #нужен для перевода из p в 10 (степень, в которую будет возводиться основание при умножении на цифры числа)

	#это строку вида A24B4D преобразовывает в [10,2,4,11,4,13]
	for i in range(len(m)):
		temp=m[i]
		if temp in a:
			#если этот символ есть в списке а, значит это сс с основанием больше 9
			#a.index(temp) возвращает индекс элемента. Удобно то, что А с индексом 0, В с индексом 1 и т.д., т.к. А=10, а В=11. Можно легко 
			#записать операцию так, как это сделано:
			temp=10+(a.index(temp))
		c.append(temp)

	#перевод собственно из p в 10                                                           3 2 1 0
	#список с содержит "цифры" исходного числа, то есть А=10, В=11 и т.д. Перевод идет так: a b c d (n) = a*n^3 + b*n^2 + c*n + d*n^0 (10)
	#a,b,c,d это и есть значения из списка с.
	for i in range(power):
		ten+=int(c[i])*(p**(power-i-1))

	#если требуется перевести в 10-ичную сс, мы это уже сделали. Возвращаем.
	if k==10:
		return ten

	#Ну а если нет, то сюда. Создается новая пустая строка. Остаток от деления ten (10-ичного числа) на основание новой сс приписывается новой 
	#строке спереди. Почему? Потому что когда мы переводим из 10 в другую сс, мы делим на основание, а потом записываем остатки в обратном
	#порядке. Здесь они сразу вперед записываются, поразрядно. Если ten % k  >  9 (то есть если остаток, который мы собираемся 
	#приписывать, больше 9, то нужно его представлять в виде буквы). Делается это несложно, опять-таки потому что А с индексом 0, В с индексом 1
	#и т.д. Мы берем остаток от деления остатка(который нужно приписать) на 10, таким образом находим индекс нужного элемента в а (0-А,1-В и т.д)
	#ну и в конце ten нацело делится на 10, убирая уже переконвертированный разряд. 
	else:
		newNum = ''
		while ten > 0:
			if ten%k>9:
				newNum = a[(ten % k)%10] + newNum
			else:
				newNum = str(ten % k) + newNum
			ten //= k
		return newNum
	
def Factor(n):
	#Функция, возвращающая список с делителями числа n. 
	#Если число p входит в разложение больше, чем в 1 степени, то оно просто повторяется. Например Factor(4) -> [2,2]
	a = [] #в этот список будут добавляться делители
	d = 2 #первый простой множитель, на который будем делить - 2
	while d * d <= n:
		if n % d == 0: #если делится, добавляем в список как простой множитель
			a.append(d)
			n //= d #а затем делим на него нацело
		else:
			d += 1 #если не делится, прибавляем 1, делим на другое число. 
			#деления на не простое число не произойдет, т.к. когда d дойдет до не простого, например 4, то все 2 из факторизации уже будут удалены
	if n > 1:
		a.append(n) #добавляем оставшееся после деления число, не поделившееся больше ни на что(если конечно оно больше 1)
	return a

def Div_Count(n):
	s=Factor(n) 
	#Нахождение количества делителей числа n, которое имеет разложение s. На вход подается число n, из которого формируется список делителей в s.
	#Согласно ОТА (основной теореме арифметики), каждое натуральное число n>1 можно единственным образом представить в виде:
	#p1^a1 * p2^a2 * ... * pn^an, где p1,p2,...,pn - простые числа, а a1,a2,...,an - натуральные (показатели)
	#При этом количество N делителей числа n находится по формуле N = (a1+1)*(a2+1)*...*(an+1), то есть к каждому показателю +1 и перемножить все
	p=[] #в список p мы поместим степени каждого множителя, то есть если например Factor(68) = [2,2,17], то мы считаем количество
	#уникальных множителей, то есть 2 двойки и одна 17. В список p должно пойти [2,1] - степени простых множителей в факторизации в порядке возрастания
	i=0 
	while i < len(s):
		#для этого будем добавлять в наш массив количество уникальных простых множителей с помощью s.count(x), которая считает, сколько раз встречается в списке значение x
		#а потом к индексу прибавляем это количество, чтобы не было повторений и мы сразу перешли бы к следующему простому числу
		p.append(s.count(s[i]))
		i+=s.count(s[i])
	print(p)
	#ну а дальше по формуле: к каждому показателю(значению списка p, там же теперь только показатели хранятся) прибавляем 1 и все это дело перемножаем в k
	k=1
	for i in range(len(p)):
		k*=(p[i]+1)
	return k

def Dividers(n):
	#Функция, возвращающая список всех делителей числа n (Работает дольше 1 секунды при n > 10^13, но до этого значения вполне приемлемо, зато код понятный)
	a = []  #массив, в котором будут записаны делители
	for i in range(1, int(n ** 0.5) + 1):  #проверяем, делится ли n на числа от 1 до sqrt(n)+1. Если да, добавляем их в массив
		if n % i == 0:
			a.append(i)
	#Теперь у нас в а хранится половина делителей n(проверяли то только до sqrt(n)+1), а есть еще парные (дел. числа 16 - 2, парный ему - 8)
	half=len(a) #сохраняем длину списка с половиной делителей
	for j in range(1,len(a)+1): #циклом добавляем вторую половину делителей, деля число на парный делитель (пробегаем по а от half до 0)
		if (n // a[half - j]) not in a: #Проверяем, не содержит ли а уже этот парный делитель(например 4 - делитель числа 16, а парный ему - тоже 4)
			a.append(n // a[half - j])  #добавляем его
	return a

def Task_23(start,end,multi=[9999],plus=[0],minus=[0],inc=[-1],ex=[-1]):
	#Использование: print(Task_23(начальное значение, конечное значение, multi=[числа, на которые умножаются], plus=[которые прибавляются], minus=[которые отнимаются], inc=[обязательные в траекториии],
	#ex=[сключаемые значения])). multi, plus, minus, inc и ex - опционально. Если нет таких условий, просто не пишете их, вызывая функцию (не передаете этот параметр, передаете только то, что нужно)
	#Для полного понимания алгоритма стоит прорешать пару задач на листочке, составляя таблицу с количеством программ для каждого числа
	#Условие задачи в общем виде выглядит так: Сколько существует программ, переводящих число start в число end, если есть команды:
	#Прибавить plus=[a,b,...] или Отнять minus=[a,b,...], Умножить на multi=[a,b,...] и при этом траектория содержит число inc=[a,b,...] и не содержит ex=[a,b,...]
	#Используются переменные параметры, ведь в задаче могут отсутствовать некоторые условия. То, что есть всегда - это конечное и начальное значение
	#Если вам не нужно какое-то из остальных условий, вы просто не пишете его в вызове функции. Их значения станут по умолчанию теми, что прописаны в параметрах и не повлияют на выполнение.
	#Задача решается динамически: создается массив, в который мы будем заполнять количество программ, переводящих начальное число в соответствующую ячейку списка
	#то есть, например, в a[1] = 1, (a[0] игнорируем, работаем с индексами от 1, так удобней), есть команда +1 и *2, тогда a[2] = 2 (можно прийти к нему прибавлением 1 к 1, или умножением на 2)
	#Проходимся по циклу от начального+1 до конечного+1 (из-за индексов) и заполняем ячейки. 
	#Сложение: Если текущее значение получается прибавлением (например в условии 1) к какому-то a, то количество программ в а мы прибавляем к текущему. 
	#Условие мы не пишем, ведь всегда можно прибавить к какому-нибудь числу значение в условии, а это число контролирует a[i - plus[j]], где оно равно i - plus[j] (plus[j]-одно из значений команд +число)
	#Т.к. чисел, которые можно прибавлять, в условии может быть несколько (для этого мы и завели массив plus, где хранятся эти значение), то мы этот алгоритм засунем во вложенный цикл,
	#который будет перебирать все значения из plus[], то есть применяя описанный алгоритм ко всем командам (числам) Прибавить.
	#Если в задаче условие на минус - это то же самое, что и на плюс, только в обратную сторону, поэтому в случае введения в функцию значений minus, мы просто меняем местами start и end,
	#а plus присваиваем значения из minus. 
	#Умножение: Если текущее значение делится нацело на число в условии (команде на умножение), то количество программ в i // multi[j] мы прибавляем к текущему.
	#(i // multi[j] - число, при умножении которого на multi[j](число из команды *) получается текущее значение). Так же, как и со сложением, работает перебор значений в multi[] (всех чисел из команд *)
	#Исключение числа: Если нам не нужно, чтобы прога проходила через данное число, мы просто обнуляем ячейку нашего массива с этим индексом(что одновременно является и значением, ибо начинаем с 1)
	#Т.к. значений, которые нужно исключить, может быть несколько, создается массив ex, в котором они сохраняются. А потом известным вам образом перебираются все его значения вложенным циклом
	#Обязательное включение: Если нам обязательно нужно, чтобы прога прошла через какое-то значение, значит, она не должна проходить ни через какие до него, поэтому значения количества программ
	#во всех ячейках до этого числа мы обнулим, чтобы при прибавлении 0 ничего не менялось. Делается это обычным вложенным циклом от start до самого этого значения inc[k]
	#Таким же образом все это помещено еще в один вложенный цикл, т.к. значений, которые нужно обязательно включить, может быть несколько, ну вы уже знаете.
	#После выполнения алгоритма искомое количество программ будет находиться в последней (end-ной) ячейке массива а. Возвращаем его.
	a = [0]*(end+1) #создание массива для хранения количества программ. Обязательно на 1 больше размер, т.к. начинаем работать с 1
	a[start] = 1 #задаем начальное значение, с какого нужно считать. Оно всегда равно 1, то есть количество программ, чтобы прийти туда, всегда 1, то есть ничего не делать.
	#Все значения массива до a[start] будут равны 0 и не повлияют на выполнение. Да мы их и не будем трогать никак.
	if minus[0]!=0: #Если введено условие на минус (т.е. значение параметра не равно значению по умолчанию), меняем start и end местами, plus присваиваем значения из minus 
		start, end = end, start
		plus = minus.copy() #чтобы именно значения передались, а не ссылка (хотя ничего не произойдет, даже если просто написать plus = minus в данной проге) 
	#Поехали, цикл от a[start+1] т.к. первое значение мы уже заполнили. end+1 потому что сдвиг на 1.
	for i in range(start+1,end+1):
		#Умножение. По умолчанию multi[0] = 9999, для того, чтобы все остатки были разные и прога не зашла сюда, если вы не прописали значение для умножения. Конечно не будет работать, если end>9999
		for j in range(len(multi)):
			if i % multi[j] == 0:
				a[i] += a[i // multi[j]]
		#Сложение. plus[0] = 0 - значение по умолчанию. Если в задаче нет условия на +, вы его не прописываете и plus[0] становится равным 0 и прога не заходит в этот цикл.
		if plus[0]!=0:
			for j in range(len(plus)):
				a[i] += a[i - plus[j]]
		#Исключение значений(обнуление соответствующих ячеек). По умолчанию ex[0] = -1, и в случае отсутствия условия, прога не зайдет сюда, т.к. все индексы а > 0
		for j in range(len(ex)):
			if i==ex[j]:
				a[i]=0
		#Включение обзательных значений (обнуление всех до) По умолчанию inc[0] = -1, работает также, как и с исключением (ex[])
		for j in range(len(inc)):
			if i==inc[j]:
				for k in range(start,inc[j]):
					a[k]=0
	#Возвращаем значение последней ячейки - искомое количество путей в нее.
	return a[end]

def Palindrome(n):
	#Проверяет, является ли число n палиндромом
	n=str(n) #переводим число n в строку, чтобы проверить, читается ли оно одинаково с обоих сторон. Если нет - то не палиндром.
	for i in range(len(n)):
		if n[i]!=n[len(n)-i-1]: #проверка на то, одинаковые ли цифры на одном и том же расстоянии от начала и конца (например 12321, сначала сравниваются 1 и 1, потом 2 и 2, а 3 совпадают)
			return False #если вдруг не одинаково читается с обоих сторон - возвращаем False
	return True #если условие не выполнилось, то число n - палиндром. Возвращаем True

def Prime(n):
	#Проверяет, является ли число n простым. Самый простой неэффективный алг.
	#Если число n не простое, то его можно представить в виде n = a*b, где a <= sqrt(n) или b <= sqrt(n), поэтому среди его множителей найдется число от 2 до sqrt(n). Значит можно проверять до sqrt(n).
	if n<2:
		return False
	for i in range(2,int(n**0.5)+1): #Если поделится хоть 1 раз, то число не простое, возвращаем False. 
		if n%i==0:
			return False
	return True

#Этот алгоритм можно ускорить, если, например, проверять только делимость на нечетные числа, а деление на 2 рассмотреть отдельно. Но можно делать это горадо более эффективно.
#Решето Эратосфена - это алгоритм предварительной обработки, который строит массив sieve, позволяющий для каждого целого числа от 2 до n эффективно определить, является ли оно простым
#Если число x - простое, то sieve[x] = 0, иначе sieve[x] = 1. Содержимое массива sieve для n = 20:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
#                                                                                                  [0,0,0,0,1,0,1,0,1,1,1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1]
#Алгоритм перебирает числа от 2 до n, при этом, обнаружив новое простое число x, он помечает, что числа 2x, 3x, 4x и т.д. не простые, т.е. заполняет единицами элементы массива с этими индексами 
#Пример реализации на python:
#
#n = {до какого числа строить массив}
#sieve = [0]*(n+1)
#for i in range(2,n+1):
#	if sieve[i]: continue | если sieve[i] == 1, то число i - не простое, тогда пропускаем эту итерацию
#	for j in range(i*2,n+1,i): | 
#		sieve[j]=1
#
#Работает это так: начинаем с 2, sieve[2] = 0, поэтому итерация не пропускается, заходим в цикл, там всем элементам массива sieve с четными индексами, начиная с 4 (2*i) (то есть все четным числам)
#присваивается значение 1. То есть все числа, кратные 2 сразу помечаются как не простые. Далее, sieve[3] = 0, итерация не пропускается и все элементы, кратные 3, начиная с 6, помечаются не простыми.
#Далее sieve[4] = 1, итерация пропускается, и так далее. 
#
#Пример реализации на c++:
#
#int n;
#cin >> n;
#int sieve[n]={};
#for (int x=2; x <= n; x++){
#    if (sieve[x]) continue;
#        for (int u = 2*x; u<=n; u+=x){
#            sieve[u] = 1;
#        }
#    }
#
#(Антти Лааксонен "Олимпиадное программирование" 11.1.2)
